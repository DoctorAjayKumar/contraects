/*
 * Maerket Base Contract
 *
 * Author:      Craig Everett <ceverett@tsuriai.jp>
 * Copyright:   Tsuriai Corporation (2022)
 * License:     GPLv3
 * Version:     0.1
 *
 * This is the base contract for the maerket.
 * It is responsible for:
 *   - A library of valid contracts by type (sales offers, auctions, etc.)
 *   - Managing the authorized key list of maerket maesters
 *   - Providing a single known endpoint to discover deployed, active contracts
 *   - Manaing the lifecycle of a maerket contract
 *
 * Lifecycle of a sales offer:
 *   1. The seller calls MaerketBase.post_sale() to create his SaleOffer
 *   2. Sale proceeds
 *     IF it is succesful, the contract calls MaerketBase.drop()
 *     IF it is revoked by seller, the contract calls MaerketBase.drop()
 *     IF it times out or is killed by the maesters, one calls MaerketBase.kill()
 */

@compiler == 6.1

include "List.aes"

contract interface SaleOffer =
    entrypoint init : (address, int, int) => void
    payable entrypoint kill : () => void


contract MaerketBase =
    record state =
        {contracts : map(int, SaleOffer),
         template  : SaleOffer,
         maesters  : list(address),
         tsuriai   : address}

    stateful entrypoint init(template : SaleOffer,
                             maesters : list(address),
                             tsuriai  : address) : state = 
        {contracts = {},
         template  = template,
         maesters  = maesters,
         tsuriai   = tsuriai}

    public entrypoint template() : SaleOffer =
        state.template

    public entrypoint lookup(id: int) : option(SaleOffer) =
        switch(Map.lookup(id, state.contracts))
            Some(target) =>
                Some(target)
            None =>
                None

    public stateful entrypoint post_sale(id: int, price: int) : option(SaleOffer) =
        require(!Map.member(id, state.contracts), "Sale already exists")
        switch(Chain.clone(ref       = state.template,
                           protected = true,
                           Contract.address,
                           id,
                           price))
            Some(posted) =>
                put(state{contracts = state.contracts{[id] = posted}})
                Some(posted)
            None =>
                abort("Bad sale!")

    public stateful entrypoint conclude(id: int) : bool =
        switch(Map.lookup(id, state.contracts))
            Some(target) =>
                require(target.address == Call.caller, "Bad caller")
                put(state{contracts = Map.delete(id, state.contracts)})
                true
            None =>
                false

    public stateful entrypoint update_maesters(keys: list(address)) =
        require(Call.caller == state.tsuriai, "You didn't say the magic word!")
        put(state{maesters = keys})

    public stateful entrypoint kill(id: int) : bool =
        require(List.contains(Call.caller, state.maesters), "You're not a killer")
        switch(Map.lookup(id, state.contracts))
            Some(target) =>
                put(state{contracts = Map.delete(id, state.contracts)})
                target.kill()
                true
            None =>
                false
